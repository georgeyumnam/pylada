

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Parallel execution of a job-folder with per-folder numbers of processors &mdash; Pylada 1.0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="top" title="Pylada 1.0 documentation" href="../../index.html" />
    <link rel="up" title="Process Module" href="../process.html" />
    <link rel="next" title="Vasp Module" href="../vasp.html" />
    <link rel="prev" title="Parallel execution of a job-folder" href="jobfolder.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../vasp.html" title="Vasp Module"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="jobfolder.html" title="Parallel execution of a job-folder"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">Pylada 1.0 documentation</a> &raquo;</li>
          <li><a href="../../pyapi.html" >Python API</a> &raquo;</li>
          <li><a href="../process.html" accesskey="U">Process Module</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="parallel-execution-of-a-job-folder-with-per-folder-numbers-of-processors">
<h1>Parallel execution of a job-folder with per-folder numbers of processors<a class="headerlink" href="#parallel-execution-of-a-job-folder-with-per-folder-numbers-of-processors" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="pylada.process.pool.PoolProcess">
<em class="property">class </em><tt class="descclassname">pylada.process.pool.</tt><tt class="descname">PoolProcess</tt><big>(</big><em>jobfolder</em>, <em>outdir</em>, <em>processalloc</em>, <em>maxtrials=1</em>, <em>keepalive=False</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../../_modules/pylada/process/pool.html#PoolProcess"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pylada.process.pool.PoolProcess" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="jobfolder.html#pylada.process.jobfolder.JobFolderProcess" title="pylada.process.jobfolder.JobFolderProcess"><tt class="xref py py-class docutils literal"><span class="pre">pylada.process.jobfolder.JobFolderProcess</span></tt></a></p>
<p>Executes folder in child processes.</p>
<p>Much as its base class,
<a class="reference internal" href="jobfolder.html#pylada.process.jobfolder.JobFolderProcess" title="pylada.process.jobfolder.JobFolderProcess"><tt class="xref py py-class docutils literal"><span class="pre">JobFolderProcess</span></tt></a>, this process
specialization is intended to run jobs in a jobfolder in parallel <a class="footnote-reference" href="#id4" id="id1">[*]</a>.
However, it allows to customize the number of processors dedicated to
each job, rather than use the same number of processors for each job.</p>
<p>The customization is done <em>via</em> the function <a class="reference internal" href="#pylada.process.pool.PoolProcess.processalloc" title="pylada.process.pool.PoolProcess.processalloc"><tt class="xref py py-attr docutils literal"><span class="pre">processalloc</span></tt></a>. It
takes one argument, the executable jobfolder, and returns an integer
signifying the requested number of processors.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">processalloc</span><span class="p">(</span><span class="n">folder</span><span class="p">):</span>
  <span class="k">return</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">folder</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>

<span class="n">process</span> <span class="o">=</span> <span class="n">PoolProcess</span><span class="p">(</span><span class="n">jobfolder</span><span class="p">,</span> <span class="n">outdir</span><span class="o">=</span><span class="s">&#39;here&#39;</span><span class="p">,</span> <span class="n">processalloc</span><span class="o">=</span><span class="n">processalloc</span><span class="p">)</span>
<span class="n">process</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">comm</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span> <span class="n">process</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
<span class="k">except</span> <span class="n">Fail</span><span class="p">:</span> <span class="k">pass</span>
</pre></div>
</div>
<p>The interface is much the same as any other process. However, it takes as
argument this <a class="reference internal" href="#pylada.process.pool.PoolProcess.processalloc" title="pylada.process.pool.PoolProcess.processalloc"><tt class="xref py py-attr docutils literal"><span class="pre">processalloc</span></tt></a> function, on top of the jobfolder
itself. In this case, each folder will be launched with approximately as
many processors as there are atoms in the structure <a class="footnote-reference" href="#id5" id="id2">[†]</a>.</p>
<p>Once it is launched, the <a class="reference internal" href="#pylada.process.pool.PoolProcess" title="pylada.process.pool.PoolProcess"><tt class="xref py py-class docutils literal"><span class="pre">PoolProcess</span></tt></a> instance will attempt to
run as many jobs as possible in parallel, until there it runs out of
processors to allocate. Howe many processors, and which machines, is
determined by the communicator passed to <a class="reference internal" href="#pylada.process.pool.PoolProcess.start" title="pylada.process.pool.PoolProcess.start"><tt class="xref py py-meth docutils literal"><span class="pre">start()</span></tt></a>. Each time an
executable folder is finished <a class="footnote-reference" href="#id6" id="id3">[‡]</a>, it tries again to pack jobs into the
available processor pool.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Upon failure, <a class="reference internal" href="../process.html#pylada.process.Fail" title="pylada.process.Fail"><tt class="xref py py-exc docutils literal"><span class="pre">Fail</span></tt></a> is raised only
once all the folders have been executed, not when the failure is
detected.</p>
</div>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[*]</a></td><td>Several job-folders are executed simultaneously, not
withstanding the possibility that each of these is also executed in
parallel <em>via</em> MPI.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[†]</a></td><td>Apparently, this is a pretty good rule-of-thumb for VASP
calculations.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[‡]</a></td><td>More, specifically, each time
<a class="reference internal" href="jobfolder.html#pylada.process.jobfolder.JobFolderProcess.poll" title="pylada.process.jobfolder.JobFolderProcess.poll"><tt class="xref py py-meth docutils literal"><span class="pre">poll()</span></tt></a> is called.</td></tr>
</tbody>
</table>
<dl class="method">
<dt id="pylada.process.pool.PoolProcess.__init__">
<tt class="descname">__init__</tt><big>(</big><em>jobfolder</em>, <em>outdir</em>, <em>processalloc</em>, <em>maxtrials=1</em>, <em>keepalive=False</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../../_modules/pylada/process/pool.html#PoolProcess.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pylada.process.pool.PoolProcess.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes a process.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>jobfolder</strong> (<a class="reference internal" href="../jobfolder/jobfolder.html#pylada.jobfolder.jobfolder.JobFolder" title="pylada.jobfolder.jobfolder.JobFolder"><tt class="xref py py-class docutils literal"><span class="pre">JobFolder</span></tt></a>) &#8211; Jobfolder for which executable folders should be launched.
The name of the folders to launch are determined which
<a class="reference internal" href="#pylada.process.pool.PoolProcess.__init__" title="pylada.process.pool.PoolProcess.__init__"><tt class="xref py py-meth docutils literal"><span class="pre">__init__()</span></tt></a> is acalled. If <tt class="docutils literal"><span class="pre">jobfolder</span></tt> changes, then one
should call <a class="reference internal" href="#pylada.process.pool.PoolProcess.update" title="pylada.process.pool.PoolProcess.update"><tt class="xref py py-meth docutils literal"><span class="pre">update()</span></tt></a>.</li>
<li><strong>outdir</strong> (<em>str</em>) &#8211; Path where the python child process should be executed.</li>
<li><strong>processalloc</strong> ((<a class="reference internal" href="../jobfolder/jobfolder.html#pylada.jobfolder.jobfolder.JobFolder" title="pylada.jobfolder.jobfolder.JobFolder"><tt class="xref py py-class docutils literal"><span class="pre">JobFolder</span></tt></a>)-&gt;int) &#8211; Function which determines how many processors each job requires.
This is determined for each job when this instance is created. To
change <a class="reference internal" href="jobfolder.html#pylada.process.jobfolder.JobFolderProcess.jobfolder" title="pylada.process.jobfolder.JobFolderProcess.jobfolder"><tt class="xref py py-attr docutils literal"><span class="pre">jobfolder</span></tt></a>,
one should call <a class="reference internal" href="#pylada.process.pool.PoolProcess.update" title="pylada.process.pool.PoolProcess.update"><tt class="xref py py-meth docutils literal"><span class="pre">update()</span></tt></a>.</li>
<li><strong>keepalive</strong> (<em>bool</em>) &#8211; Whether to relinquish communicator once jobs are completed.  If
True, the communicator is not relinquished. The jobfolder can be
<a class="reference internal" href="#pylada.process.pool.PoolProcess.update" title="pylada.process.pool.PoolProcess.update"><tt class="xref py py-meth docutils literal"><span class="pre">updated</span></tt></a> and new jobs started. To finally
relinquish the communicator,
<a class="reference internal" href="jobfolder.html#pylada.process.jobfolder.JobFolderProcess.keepalive" title="pylada.process.jobfolder.JobFolderProcess.keepalive"><tt class="xref py py-attr docutils literal"><span class="pre">keepalive</span></tt></a>
should be set to False.  Both
<a class="reference internal" href="jobfolder.html#pylada.process.jobfolder.JobFolderProcess.kill" title="pylada.process.jobfolder.JobFolderProcess.kill"><tt class="xref py py-meth docutils literal"><span class="pre">kill()</span></tt></a> and
<a class="reference internal" href="jobfolder.html#pylada.process.jobfolder.JobFolderProcess.terminate" title="pylada.process.jobfolder.JobFolderProcess.terminate"><tt class="xref py py-meth docutils literal"><span class="pre">terminate()</span></tt></a> ignore
this attribute and relinquish the communicator. However, since both
side effects, this may not be the best way to do so.</li>
<li><strong>maxtrials</strong> (<em>int</em>) &#8211; Maximum number of times to try re-launching each process upon
failure.</li>
<li><strong>kwargs</strong> &#8211; Keyword arguments to the functionals in the executable folders. These
arguments will be applied indiscriminately to all folders.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pylada.process.pool.PoolProcess.processalloc">
<tt class="descname">processalloc</tt><em class="property"> = None</em><a class="headerlink" href="#pylada.process.pool.PoolProcess.processalloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines number of processors to allocate to each job.</p>
<p>This is a function which takes a
<a class="reference internal" href="../jobfolder/jobfolder.html#pylada.jobfolder.jobfolder.JobFolder" title="pylada.jobfolder.jobfolder.JobFolder"><tt class="xref py py-class docutils literal"><span class="pre">JobFolder</span></tt></a> instance and returns an
integer.</p>
</dd></dl>

<dl class="method">
<dt id="pylada.process.pool.PoolProcess.start">
<tt class="descname">start</tt><big>(</big><em>comm</em><big>)</big><a class="reference internal" href="../../_modules/pylada/process/pool.html#PoolProcess.start"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pylada.process.pool.PoolProcess.start" title="Permalink to this definition">¶</a></dt>
<dd><p>Start executing job-folders.</p>
</dd></dl>

<dl class="method">
<dt id="pylada.process.pool.PoolProcess.update">
<tt class="descname">update</tt><big>(</big><em>jobfolder</em>, <em>deleteold=False</em><big>)</big><a class="reference internal" href="../../_modules/pylada/process/pool.html#PoolProcess.update"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pylada.process.pool.PoolProcess.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates list of jobs.</p>
<p>Adds jobfolders which are not in <tt class="docutils literal"><span class="pre">self.jobfolder</span></tt> but in the input.
Deletes those which in <tt class="docutils literal"><span class="pre">self.jobfolder</span></tt> but not in the input.
Does nothing if job is currently running.
Finished jobs are not updated.
If <tt class="docutils literal"><span class="pre">deleteold</span></tt> is True, then removed finished jobs from job-folder.</p>
<p>Processes jobfolder from root, even if passed a child folder.</p>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="jobfolder.html"
                        title="previous chapter">Parallel execution of a job-folder</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../vasp.html"
                        title="next chapter">Vasp Module</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../../_sources/pyapi/process/pool.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../vasp.html" title="Vasp Module"
             >next</a> |</li>
        <li class="right" >
          <a href="jobfolder.html" title="Parallel execution of a job-folder"
             >previous</a> |</li>
        <li><a href="../../index.html">Pylada 1.0 documentation</a> &raquo;</li>
          <li><a href="../../pyapi.html" >Python API</a> &raquo;</li>
          <li><a href="../process.html" >Process Module</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Mayeul d&#39;Avezac.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>